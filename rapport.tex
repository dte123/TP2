\documentclass{article}
\usepackage{geometry}
\geometry{a4paper,scale=0.7}
\usepackage[utf8]{inputenc}

\title{Rapport TP2}

\author{Rosine Rolande Simo Tegninko, 20183729\\
Yu Deng, 20151659}

\date{}

\begin{document}

\maketitle

\section*{Tâche 1}

\item$\textbf{(Q1)}$
Pour le Q1, nous avons choisi deux métriques, NCH et Nombre de tests.

1.	NCH fait référence au nombre de commits dans l'historique de la classe. Ensuite, nous pouvons juger s'il est adapté à sa complexité en regardant le nombre de commits. Voici pourquoi : s'il y a trop de commits, alors on sait aussi que la personne qui a écrit ce code le met constamment à jour afin de pouvoir l'adapter à la complexité.

2.Plusieurs tests sont sûrs de trouver de nombreux problèmes. Et pour chaque test, nous devons "augmenter" la complexité de "l'entrée" pour détecter si le niveau de document de la classe est approprié à sa complexité.


\item $\textbf{(Q2)}$
Pour le Q2, nous avons choisi deux métriques, NLF(Le nombre de lignes de code d’une fonction) et LCOM.

1. De manière générale, une fonction ne doit pas dépasser 40 lignes de code. S'il y a trop de couches de fonctions, cela affectera notre jugement logique lors de la vérification du code.

2. Plus le score LCOM est faible, meilleure est la cohésion de sa structure et meilleur est le degré de corrélation entre les parties du module.


\item$\textbf{(Q3)}$
Pour Q3, nous avons sélectionné deux métriques, CSEC et Temps total de l’exécution.


1. CSEC fait référence à "couplage simple entre classes", nous savons que plus une classe est couplée à d'autres classes, plus une modification de cette classe peut influencer de classes. Ensuite, CSEC a joué un grand rôle en testant si le code est mature, If ce code peut avoir un CSEC inférieur, la charge de travail des tests sera également réduite.

2. Pour Temps total de l’exécution, lorsque nous testons, le résultat est très lent. Tout le monde veut obtenir une réponse le plus rapidement possible, ensuite si le temps d'exécution est lent, le code est moins mature et moins adapté aux besoins des gens.


\item$\textbf{(Q4)}$
Pour le Q4, nous avons choisi deux métriques, TPC et NEC.

1. Pour TPC, nous testons en fonction de la classe, donc au lieu de tester directement l'intégralité du code, nous pouvons juger si chaque partie peut être exécutée correctement grâce à des tests automatiques. S'il y a un bogue dans l'un d'entre eux, alors lorsque le code global est automatiquement testé, certains bogues seront trouvés.

2. Pour NEC, il est évident que si un code a beaucoup d'erreurs après son exécution, alors le code doit avoir une erreur dans un certain lien. Lors du test automatique, il a dû rencontrer des problèmes, ensuite, ce code ne fonctionne pas bien dans les tests automatiques.\\

\section*{Tâche 2}\\
On peut répondre à la question 2 en mesurant le CSEC, ce qui est aussi plus facile à faire car on a déjà complété ce code (lcsec.py) dans le premier devoir.\\
Par exemple, si la classe MethodVisitor a un CSEC=3, la sortie du lcsec doit avoir, parmi autres, la ligne :

./gr/spinellis/ckjm/MethodVisitor.java, gr.spinellis.ckjm, MethodVisitor, 3\\

\section*{Tâche 3}\\

\item$\textbf{(Q4)}$
Explication : Nous vérifions d'abord directement le nombre de soumissions et enregistrons les données détaillées. Plus tard, nous entrons quelques données, telles que la création de différents types d'histogrammes, et voyons les résultats finaux.

Réponse : Oui. D'après les résultats obtenus, vous pouvez dire que le niveau de documentation des classes est-il approprié par rapport à leur complexité.

\item$\textbf{(Q2)}$
Explication : Nous pouvons choisir n'importe quelle fonction et vérifier son nombre de lignes, ce qui peut être facilement jugé. En observant le nombre de lignes de fonction, nous pouvons également sélectionner une partie du code pour calculer LCOM.

Réponse : Oui. La plupart des fonctions ne sont pas très compliquées et peuvent être présentées clairement. Et le LCOM est également faible, donc la cohésion est bonne.

\item$\textbf{(Q3)}$
Explication : CSEC peut être mesuré par le code dans TP1. Pour le temps d'exécution total, faites un histogramme en Q1, puis je peux également obtenir le temps d'exécution final.

Réponse : Oui. La plupart des classes ont un faible couplage, le temps d'exécution n'est pas lent et les résultats souhaités peuvent être obtenus rapidement.

\item$\textbf{(Q4)}$
Explication : Nous sélectionnons d'abord quelques classes, les testons individuellement et voyons les résultats. Nous sélectionnons directement la fonction de test à tester et voyons le nombre final d'erreurs.

Réponse : Nous pouvons voir qu'il existe des fonctions de test dans jfreechart, nous pouvons donc les tester séparément. Si le nombre d'erreurs est faible, le code peut-il être testé bien automatiquement.\\

\item$\textbf{Une évaluation du niveau de maintenabilité du JFreeChart:}$\\
Sur la base des réponses aux quatre questions ci-dessus sur le code JFreeChart, il est clair que le code est modérément maintenable. Le résultat final souhaité est presque toujours satisfait après la mesure à l'aide des métriques.\\
Cependant, peut-être que d'autres améliorations peuvent être apportées dans le couplage des classes. Un système à faible couplage a une meilleure réutilisabilité, maintenabilité et évolutivité, et peut compléter la maintenance et le développement du système plus efficacement, et soutenir en permanence le développement du système sans devenir un obstacle au développement du système.


\end{document}
